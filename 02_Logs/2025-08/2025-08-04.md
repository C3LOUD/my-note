
---

## ‚úÖ What I Did Today
- 

---

## üìö What I Learned
### Misc
- Partially import do help tree shaking to reduce bundle size but nothing much memory, it still need to load entire chunk into memory and reach the code
- use dynamic import `import()` instead to make bundler split the code and browser loads it on demand
- Top level import will immediately load into memory
- Multi entry in bundler means each entry will have it's own dependency graph, it makes two entry totally isolate from each other, so it makes a MPA but not SPA
- `base` in `defineCofnig`  of `vite.config.js` means where do the file host, like if for domain `example.com` I run nginx listen on `location /my-app/ {` then the `base` represent `my-app` vite will update all the path to the static file via `base`
### SQL Injection and Safe Queries
* SQL injection happens when untrusted input is parsed as SQL code
* Parameterized queries use placeholders (`?`, `$1`) to separate code from data
* Interpolated input (e.g., `${id}`) is unsafe and vulnerable
* Binding prevents injection by sending data separately from SQL structure
### Driver Binding Mechanism
* Drivers use native protocols (e.g., MySQL's `COM_STMT_PREPARE`) for binding
* Bound values are binary, not strings, and never parsed as SQL
* Binding is secure even if user input looks malicious (e.g., `1; DROP TABLE users; --`)
### Manual SQL Execution
* Safe manual query:
  ```sql
  PREPARE stmt FROM 'SELECT * FROM users WHERE id = ?';
  SET @id = 42;
  EXECUTE stmt USING @id;
  ```
* Interpolating into `SET @id = ${input}` is unsafe and allows injection
* Manual SQL only treats `?` as placeholder inside `PREPARE`, not regular queries
### SQL Engine Behavior
* SQL strings are parsed into ASTs and executed
* Interpolated input becomes part of the AST and can alter logic
* Bound parameters skip parsing and are plugged into precompiled plans
### Memory and Storage
* SQL engines use memory for execution plans, not just disk
* `PREPARE` stores execution plans with param slots (not memory addresses)
* Table data lives on disk, accessed via in-memory buffer pool
### SQLite VM Internals
* SQLite compiles SQL into bytecode for a custom VM
* It uses instructions like `Column`, `ResultRow`, `Halt`, etc.
* SQLite is a stack-based VM ‚Äî conceptually an emulator
### Vite Environment Variables
- `import.meta.env` variables in Vite are replaced statically at **build time**.
- In **development** mode (`npm run dev`), Vite injects `import.meta.env.*` dynamically at **startup**.
- Changing `.env` values requires **restarting the dev server** to take effect.
- During **build**, values from `import.meta.env` are **hardcoded into the final JS** files.
- Changing environment variables after build has **no effect** unless you rebuild.
- `VITE_` prefix is required for any custom environment variable to be exposed to `import.meta.env`.
### Nginx Proxy Behavior
- `proxy_pass http://host/;` (with trailing slash) strips the matching `location` path prefix
- `proxy_pass http://host;` (without trailing slash) preserves the full original request URI
- `location /foo/` matches `/foo/`, `/foo/bar`, but not `/foo`
- `location /foo` matches `/foo`, `/foo-bar`, `/food`, etc. ‚Äî it's a loose prefix match
- Always add a trailing slash to `location` if you want predictable matching
- Use `location = /foo` to match exactly `/foo` (nothing more)
- Avoid using `location /foo` without `/` for proxying ‚Äî leads to ambiguous path rewrites
- Combining `location = /foo` and `location /foo/` gives you full control over exact match and subpath behavior
```nginx
location = /foo {
  proxy_pass http://backend:8000/foo;
}

location /foo/ {
  proxy_pass http://backend:8000/;
}
```
### Docker Compose and Build Target
- `build.target` in `docker-compose.yml` lets you specify which stage of a multi-stage Dockerfile to stop at
- Only the stages above or up to the specified `target` will be built
- Later stages (after the target) will be ignored completely
- Docker will still build earlier stages if they are referenced (e.g., via `COPY --from=...`)
- Useful for switching between `dev-stage` and `prod-stage` using one Dockerfile
- Enables reusing a single Dockerfile for both development (`npm run dev`) and production (`npm run build`)
### Docker `ARG` vs `ENV`
* `ARG` is a **build-time variable**, only available during Docker image creation.
* `ENV` is a **runtime variable**, available to the container after it's built.
* `ARG` values are **not** persisted in the final image.
* `ENV` values **are** persisted and visible in the container environment.
* You can use `ARG` to inject values into `ENV` during build:

```dockerfile
  ARG APP_ENV
  ENV NODE_ENV=$APP_ENV
```
### What do `target`, `module`, `moduleResolution` do in `jsconfig.json`
- `jsconfig.json` is for editor only while `tsconfig.json` is for editor and compiler
- `target` means which version of javascript syntax should emit
- `module` means which module system to use, `ESM` or `Common.js`
- `moduleResolution` means how to resolve imports
	- `classic`  only resolve relative paths
	- `node` mimics `Node.js` supports `node_modules`, `baseUrl`, `paths`
### History of JavaScript Modules
- Start with no module, everything is global
```html
<script src="a.js"></script>
<script src="b.js"></script>
```
- `Node.js` invents its own module system CommonJS `require`
	- it only works in node runtime but no browser
- Module Bundlers came in `Browserify`, `Webpack`
	- it helps browser to use the module system by read the `require` statement and build a version for browser to run
- ES6 came out, ECMAScript officially support module system `import` `export`
	- It still do not understand `node_modules`, but now import from relative path work
- Node support ESM, using `.mjs` extension, later, Node allow to setup `"type": "module"` in package.json to directly use ESM
- Modern Tools like `Vite`, `Webpack`, `Rollup`
	- Now ESM works on browser and node runtime, bundler helps to close the gap between `Commonjs` and ESM, to allow developer use node_modules for build app for browser, it transform imports to browser-compatible code
- Use Vite in dev mode 
	- bundler will find the `import` statement in the source code, based on the moduleResolution setting, find where the module is
	- Then pre-bundles dependencies using `esbuild`, convert `CommonJS` into `ESM` if needed
	- After that create cache in `.vite/deps/` then update the import statement in source code
	- Serve the js files directly via dev server
```javascript
import axios from "/@vite-deps/axios.js?v=123456"
```
- Use Vite in production mode
	- Vite Rollup walks the import graph use `main.js` as entrypoint
	- Resolve all files then flattens into optimized JS chunks and tree-shaken code
	- Rollup convert all module into ESM if needed, inline only the code actually use via tree shaking
	- The artifact is the file chunks with hash, all import statement got updated using hashed `js` file name

 
---

## ‚ùì Questions That Came Up
- [ ] 

---

## üß† Quick Notes / Brain Dump
- How do import statement makes http request for the real script

---

## ü™ú Next Steps / Follow-ups
- 