
---

## âœ… What I Did Today
- 

---

## ðŸ“š What I Learned
### Misc
- `ss` command is to see the socket state
- PROXY protocol prepend header of the regular http packet
- PROXY protocol works on Layer 7, Socks5 PROXY works on Layer 5 (RFC 1928)
- OSI model is just an idea but not real implementation, the step beyond L4 is technically the same
- TUN/TAP is virtual network interface for tunnel
- STUN is a nat traversal protocol to discover the public ip behind NAT
- TCP is stream based, UDP is packet based
- TCP promise the order of the data, but do not promise the boundary of a packet
- UDP promise the boundary of a packet but do not promise the order of the packet and do not even promise the packet will delivered
- An echo server is a server sends back whatever it receives, it's a test pattern
- The interrupt handler also called interrupt service routine is a function in OS, it halt the current task on cpu and cpu jumps to interrupt vector to process the event, then back to the original task
### Class in Python
- `__del__` got called when use `del` keyword in python
- `del` will release the memory of that reference
- `@property` decorator makes the property can got called with syntax `instance.property`
- `@property.setter` decorator makes the property can be assign value via `instance.property = value`
- `del` only release the memory but all non-memory resources, external resources won't got clean up
### Socket
- A socket is an interface that sits between the kernel and user space
- The kernel parses the packet and triggers the appropriate handler based on the header
- Communication between the kernel and user space applications is achieved using socket
- Both client and server bind to socket to send packet
- When bind socket, you should give the source ip, source port, dest ip, dest port to socket, and it automatically become the identifier of the socket
- A socket works on Layer 4, it listen to the packet from Layer 3 and bypassing the packet to the correspond socket via header
- A socket is a two way binding connection and allow two way data transport
- Each side can close the connection by sending the empty byte
- On client, it just have to bind the socket and sends the byte
- On server, it have to first bind a port to listen packet goes in from the socket, when it accept the packet, it will create a new socket named 'connection', the identifier of connection will be the 4 tuple, the connection object will last till it got closed
- A socket is a file descriptor [[2025-07-28#^a2b494]]
- You can find sockets in `/proc/$$/fd` [[2025-07-28#^05ea64]]
- The matching table is in `/net/ipv4/inet_hashtables.c`
- `/proc/net/tcp` holds the TCP sockets and 4 tuples
- A socket can be `ehash` or `lhash2` which means established or listening
### Packet flows in OSI layers model
#### Layer 1
- The data (bitstream) is sent as electrical, optical, or radio signals
- Travel through fiber, copper, or air
- Modulates/demodulates analog signal and digital signal
- Pass digital data to router or switch via Ethernet (Layer 2)
#### Layer 2
- A stream of bits that it interprets as an Ethernet frame
- The frame holds MAC address and payload
- The payload is the IP packet
##### NIC
- NIC receives bits off the wire and reassembles into the complete ethernet frame
- NIC do hardware-level check like CRC then delivers the frame into DMA
- NIC notify driver in kernel the frame arrives
#### Layer 3
##### Router and L3-Switch
- Router reads destination IP from the IP packet
- Update IP header
- Forwards to the next hop, mostly the NIC
##### NIC
- Driver in kernel wraps frames in DMA into socket buffer `struct sk_buff`
- OS kernel network stack parse the IP packet and check destination IP match the interface of the server, check IP header checksum valid
- If pass all of the validation, strips the IP header and passes packet to Layer 4, call the relevant handler
- `/net/ipv4/ip_input.c` called `ip_rcv(struct sk_buff *skb, struct net_device *dev)`
#### Layer 4
- The handler got called and receive the packet
- TCP as example: `/net/ipv4/tcp_input.c` called `tcp_v4_rcv(struct sk_vuff *skb)`
- The handler will tell the source, destination, so that it may find the socket with that 4 tuple identifier then send the packet to the matched socket
#### Layer beyond
- Socket API work with the packet
- Based on different protocol, packet should handle differently based on the application
### How each protocol frame the message
- HTTP/1.0 - Newlines and headers `\r\n\r\n`
- HTTP/2 - Length-prefixed binary frames
- TLS - Length-prefixed records
- Redis - Delimiter (`\r\n` based RESP)
- WebSocket - Length-prefixed or chunked frames
- DNS over TCP - 2-byte length prefix
### Socket programming in python
#### Basic of using socket
```python
# server.py
import socket

sock = socket.socket() # initiate a socket

sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)

# tell os bind this socket on which interface and which port
sock.bind(('localhost', 9000)) 

# update the status of socket to listening, pass the number to tell how many connection is allow to wait in line, that number means backlog
sock.listen(1) 
conn, _ = sock.accept() # block can wait the tcp buffer goes in

while True:
    # connection receive up to 8 byte from tcp buffer then put into variable
    data = conn.recv(8) 
    if not data:
	    # send back current data
	    sock.sendall()
        break
    print(f"Received: {data}")

# client.py
import socket

sock = socket.socket()
sock.connect(('localhost', 9000))

# Send 3 separate messages
sock.send(b'hello')
sock.send(b'world')
sock.send(b'!!!')
# when call close socket will send empty string as final byte then close the socket
sock.close()

```
#### Framing the message
##### Fixed-length Messages
```python
# Sender
sock.send(b'hello'.ljust(128))  # pad to fixed size

# Receiver
data = sock.recv(128)
```

##### Length-Prefixed Messages
```python
# Sender
msg = b'hello'
length = len(msg).to_bytes(2, 'big')  # 2-byte header
sock.send(length + msg)

# Receiver
length_bytes = sock.recv(2)
length = int.from_bytes(length_bytes, 'big')
data = b''
while len(data) < length:
    data += sock.recv(length - len(data))
print("Message:", data)
```
##### Delimiter-Base
```python
# Sender
sock.send(b'LOGIN alice\n')
sock.send(b'MSG hello\n')

# Receiver
buffer = b''
while True:
    buffer += sock.recv(1024)
    while b'\n' in buffer:
        line, buffer = buffer.split(b'\n', 1)
        print("Message:", line.decode())

```
### Threading in python
```python
import threading
# event handler that notify cross all thread, the flag can be read in all thread
my_event = threading.Event()
# flag the event
my_event.set()
# return if event is flagged
my_event.is_set()
# clean up the flag
my_event.clear()
# wait flag to set
my_event.wait()

# create lock to block all thread
lock = threading.Lock()
def dangerous():
	# automatic way to acquire and release lock
	with lock:
		# do job that may use the same variable, update the same memory reference
		return some_var

# create a new thread
thread = threading.Thread(target=handler, args=(arg1, arg2,), daemon=True)
# start running the thread
thread.start()
# don't know
thread.join()
```
### Queue in python
```python
import queue
my_queue = queue.Queue()
my_queue.get()
my_queue.put()
my_queue.task_done()
my_queue.join()

```

---

## â“ Questions That Came Up
- [ ] What do `with` keyword do in python?
- [ ] What are the differences between destructors and context managers?
- [ ] What do `__enter__` and `__exit__` do and when will they got called?
- [ ] In python I can implicitly release memory?
- [ ] What is a file descriptor? ^a2b494
- [ ] What do `$$` means in path? ^05ea64
- [ ] What do `AF_INET` , `SOCK_STREAM` mean?
- [ ] It seems like the packet goes to router first then goes to switch, do the packet first goes to layer 3 then get back to layer 2?
- [ ] IP packets is not equal to Ethernet frame?
- [ ] How do IP header checksum created?
- [ ] Socket buffer is different from receive buffer?
- [ ] Do not understand this code :
```python
# Let's say your protocol is: [4-byte length][command][payload]
length = int.from_bytes(data[0:4], 'big')
command = data[4:8].decode()
payload = data[8:8+length].decode()
```
- [ ] What do decode and encode work in python?
- [ ] How to create a TUN?
- [ ] What is STUN exactly?
- [ ] How to turn streams of byte back to string
- [ ] Is it tcp buffer or socket buffer
- [ ] Compare I/O bound and CPU bound when using thread or process
- [ ] How threading in python work? Why is it not real parallelism
- [ ] What is signal and slots mean? What do PySide6.QtCore library do?
- [ ] What is signal library in python?
- [ ] How signal work in unix?
- [ ] Should I spawn thread on the fly or reuse as worker pool?
- [ ] What is mutual exclusion (mutex)?
- [ ] What will happen for the thread that want to runs the code block by lock?
- [ ] What is `Condition`, `Semaphore` compare to lock
- [ ] When a socket call `send()`, will it also put the message in it's own buffer? Like if a client kept calling `send`, and the target server did not response anything, what will happen when client call `sendall()`?

---

## ðŸ§  Quick Notes / Brain Dump
- Create obsidian plugin to work with LLM
	- Use LLM to summarize the daily note and suggest the atomic notes should be created
	- Attach tag to the note
	- Answer the question directly in daily note of question section
	- Correct my articulation

---

## ðŸªœ Next Steps / Follow-ups
- 
