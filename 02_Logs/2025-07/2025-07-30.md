
---

## ✅ What I Did Today
- 

---

## 📚 What I Learned
### Misc
- Vue expose env prefix with `VITE_` to frontend 
- CORS is a browser security mechinism, nothing about server and source code
- Create axios instance by using `axios.create()` for reuse
- `--workers` in gunicorn use process, `-threads` use thread, `--worker-class gthread` to enables multithreading
- In javascript, thre is global `window` object with default methods in browser runtime, in python, there is `__builtins__` namespace as global object
### How Vite proxy configuration works
- It's use dev server behinds the scene
- it runs the server for vue then send request on the dev server
- This way it won't trigger cors, because browser send request to itself, then dev server handles the request to backend
- The replace setting can use regex to refactor the url
- It use http-proxy-middleware behind the scene
### How to built my own frontend framework
- Reference [repo](https://github.com/C3LOUD/my-framework.git)
- React use babel parse the JSX file into JS file
- Babel use babylon parser behind the scene
- JSX is just a tool to improve DX
- React still use native browser api behind the scene
- SPA frontend use `history.pushState()` to update the history without refresh the page.
- When `history.pushState()` got trigger, the `popstate` event will trigger, so we can add eventListener to rendering
### CSS Reset
```css
/*
  Josh's Custom CSS Reset
  https://www.joshwcomeau.com/css/custom-css-reset/
*/

*, *::before, *::after {
  box-sizing: border-box;
}

* {
  margin: 0;
}

@media (prefers-reduced-motion: no-preference) {
  html {
    interpolate-size: allow-keywords;
  }
}

body {
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}

img, picture, video, canvas, svg {
  display: block;
  max-width: 100%;
}

input, button, textarea, select {
  font: inherit;
}

p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

p {
  text-wrap: pretty;
}
h1, h2, h3, h4, h5, h6 {
  text-wrap: balance;
}

#root, #__next {
  isolation: isolate;
}
```
### What do `contextmanager` do
- it create syntax sugar for easier wrapper to work with `with` keyword
```python
import fcntl
from contextlib import contextmanager

@contextmanager
def file_lock(filepath, mode="r+"):
    with open(filepath, mode) as f:
        fcntl.flock(f, fcntl.LOCK_EX)  # Exclusive lock (use LOCK_SH for shared read)
        try:
            yield f  # give file handle to caller
        finally:
            fcntl.flock(f, fcntl.LOCK_UN)

def edit_file(path):
    with file_lock(path, mode="r+"):  # or "w" or "a", depending on what you do
        # do your file reading/writing safely

```
- it use `__enter__` and `__exit__` behind the scene
### What do `fcntl` do
- Works with file-level locking using `fcntl.flock` provide advisory lock. 
- Just a convention lock for unix-like system, it just add a flag then other process notice the flag, the program that respect this protocol will wait for the lock to unlock
- Just a soft way to do it so the program can still access to the file if they want
```python
fcntl.flock(fd, fcntl.LOCK_EX) # Lock the file
fcntl.flock(fd, fcntl.LOCK_UN) # Unlock the file
fcntl.LOCK_SH # Shared lock for read only
```
### What is `_io.TextIOWrapper`
- The `open()` will calls `_io.FileIO` and setup `TextIOWrapper` on top of it
- A low level module`_io.FileIO` directly runs built in c code, it directly calls `open()` syscall
- It wraps the underlying `_io.FileIO` , stores the buffer and decode, exposes a way to modify it
- `TextIOWrapper` provides a way to do `read()`, `write()` syscall
- This is how `open()` looks like
```python
import os

class MyOpen:
    def __init__(self, path, mode="r"):
        self.path = path
        self.mode = mode
        self.fd = None  # file descriptor

    def __enter__(self):
        flags = os.O_RDONLY if self.mode == "r" else os.O_WRONLY
        self.fd = os.open(self.path, flags)
        return self  # return self so user can call .read()

    def read(self, size=1024):
        return os.read(self.fd, size).decode()

    def write(self, data):
        os.write(self.fd, data.encode())

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(self.fd)

# 🔨 Usage
with MyOpen("hello.txt", "r") as f:
    print(f.read())

```
- Under the hood it looks like this, ctypes is a way to call code under the hood
```python
import ctypes
import os

libc = ctypes.CDLL("libc.so.6")  # Load C standard library (Linux)

# Define syscall numbers
O_RDONLY = 0

# Call open
fd = libc.open(b"hello.txt", O_RDONLY)
if fd < 0:
    raise OSError("Failed to open file")

# Read 100 bytes
buffer = ctypes.create_string_buffer(100)
n = libc.read(fd, buffer, 100)
print(buffer.raw[:n].decode())

# Close
libc.close(fd)
```
### What is a fd (File Descriptor)
- A fd is an open entry to a file
- When we called open and create a way to work with the file, the os do several things
	  1. Based on the given path, it founds the file and get the inode identifier
	  2. Check the inode table and got the real block and create a struct file in `/proc/$$/fd`
	  3. Register the struct file on file descriptor table 
	  4. return fd number which is the index of that fd
### How inode works in linux
- It create the inode table when the file system created
- A directory is also a file that holds the table that keeps the reference of the inode number for the files
- When bootstrap the file system `mkfs.ext4 -i 16384 /dev/sdX`
	- The file system have already decide a size of a block, in ext4, it's 4kib per block, which means even if a file is smaller then 4kib, it still occupy an entire block by padding
	- ext4 also define inode size, which means each inode, or each file in system is at least x big, in this case it's 16kib
	- Number of inode is capped, that means the file limitation is also capped when bootstrap the filesystem
### How disk storage works
- A disk have several sectors, usually 512bytes, sometimes 4096 ("4Kn")
- A disk split up to data blocks
- There is block bitmap, a block bitmap represent if a block is in use or free
- there is a inode bitmap table represent the mapping from inode to blcok bitmap
### How file delete works
- It remove the block reference on that inode to the block, and mark that inode is free
- The data on the disk do not got wipe out
- `debugfs` will walk through all of the inode, if there is data in the block, but the inode flagged free, that means that file is got deleted
---

## ❓ Questions That Came Up
- [ ] Why do vite need to use http-proxy-middleware but not directly use fetch?
- [ ] What is dom tree compare to fiber tree
- [ ] What is AST
- [ ] What is double buffering
- [ ] How to create physical engine
- [ ] How to use Lynis
- [ ] What is value object compare to entities
- [ ] What is cookiecutter
- [ ] How to use setuptools and pyproject.toml
- [ ] If I lock on file level, do I need to lock on the thread level?
- [ ] How disk flagged the block have data or not?
- [ ] How do data block got configured
- [ ] A data block is several sectors, is it serialized?
- [ ] What if an inode is bigger then a block, do inode reference multiple block in order but each block might spread on entire disk, which means the sector is not serialized
- [ ] Do the inode only keep the entrypoint of the block, and the block keeps the entrypoint of sector?

---

## 🧠 Quick Notes / Brain Dump


---

## 🪜 Next Steps / Follow-ups
- 